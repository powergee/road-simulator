<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="./three.js"></script>
  <script src="./vec2d.js"></script>
  <script src="./thick.js"></script>
  <style>
    body,
    html {
      margin: 0px;
      padding: 0px;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>

    // Define scene, camera, renderer.
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(
      75, // Field of view
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near clipping plane
      1000 // Far clipping plane
    );
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(
      window.innerWidth,
      window.innerHeight,
      document.body.appendChild(renderer.domElement)
    );

    function getThickLineGeometry([left, right]) {
      let n = left.length
      let vertices = []
      let faces = []

      for (let i = 0; i < n; i++) {
        vertices.push(new THREE.Vector3(left[i].x, 0, left[i].y))
        vertices.push(new THREE.Vector3(right[i].x, 0, right[i].y))
      }

      for (let i = 0; i < n - 1; i++) {
        faces.push(new THREE.Face3(
          i * 2 + 2,
          i * 2 + 1,
          i * 2 + 0))
        faces.push(new THREE.Face3(
          i * 2 + 3,
          i * 2 + 1,
          i * 2 + 2))
      }

      const geometry = new THREE.Geometry();
      geometry.vertices = vertices;
      geometry.faces = faces;
      geometry.computeBoundingSphere();

      return geometry;
    }

    // Crate lane geometry
    function getLaneGeometry(points, width = 2, thick = 0.1) {
      let [leftLanePoints, rightLanePoints] = createThickLine(points, width / 2)
      let leftLane = createThickLine(leftLanePoints, thick);
      let rightLane = createThickLine(rightLanePoints, thick);
      let leftLaneGeometry = getThickLineGeometry(leftLane);
      let rightLaneGeometry = getThickLineGeometry(rightLane);
      return [leftLaneGeometry, rightLaneGeometry];
    }

    // Define a cube and add it to scene.
    let cube;
    {
      let geometry = new THREE.BoxGeometry();
      let material = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
      });
      cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
    }


    // Define a plane
    // {
    //   const geometry = new THREE.PlaneGeometry(50, 50);
    //   const material = new THREE.MeshPhongMaterial({ color: 0x808080, side: THREE.DoubleSide });
    //   const plane = new THREE.Mesh(geometry, material);
    //   plane.position.set(0, 0, 0)
    //   plane.lookAt(0, 1, 0)
    //   scene.add(plane);
    // }

    const lane = t => new Vec2D(t * Math.PI * 20, Math.sin(t * Math.PI * 2) * 10)

    // Define lane
    {
      let points = []
      for (let i = 0; i < 1; i += 0.01) {
        points.push(lane(i));
      }
      let [leftLaneGeometry, rightLaneGeometry] = getLaneGeometry(points);
      let leftLane = new THREE.Mesh(leftLaneGeometry, new THREE.MeshBasicMaterial());
      let rightLane = new THREE.Mesh(rightLaneGeometry, new THREE.MeshBasicMaterial());
      scene.add(leftLane);
      scene.add(rightLane);
    }

    // Define lights
    {
      let light = new THREE.AmbientLight(0x404040); // soft white light
      scene.add(light);
    }
    {
      let light = new THREE.DirectionalLight(0xffffff, 0.5);
      scene.add(light);
    }

    camera.position.z = 10;

    function animate(t) {
      let t2 = ((Math.sin(t / 5000) + 1) / 2);
      let t3 = ((Math.sin((t + 2500) / 5000) + 1) / 2);
      let cam = lane(t2);
      let dst = lane(t3);

      camera.position.set(cam.x, 5, cam.y);
      cube.position.set(dst.x, 0, dst.y);
      camera.lookAt(dst.x, 0, dst.y);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate(0);
  </script>
</body>

</html>