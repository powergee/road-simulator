<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="./three.js"></script>
  <script src="./vec2d.js"></script>
  <script src="./thick.js"></script>
  <style>
    body,
    html {
      margin: 0px;
      padding: 0px;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>

    // Define scene, camera, renderer.
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      30, // Field of view
      640 / 480, // Aspect ratio
      0.1, // Near clipping plane
      1000 // Far clipping plane
    );
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(
      640,
      480,
      document.body.appendChild(renderer.domElement)
    );

    // Get geometry of thick line
    function getThickLineGeometry([left, right]) {
      const n = left.length
      let vertices = []
      let faces = []

      for (let i = 0; i < n; i++) {
        vertices.push(new THREE.Vector3(left[i].x, 0, left[i].y))
        vertices.push(new THREE.Vector3(right[i].x, 0, right[i].y))
      }

      for (let i = 0; i < n - 1; i++) {
        faces.push(new THREE.Face3(
          i * 2 + 2,
          i * 2 + 1,
          i * 2 + 0))
        faces.push(new THREE.Face3(
          i * 2 + 3,
          i * 2 + 1,
          i * 2 + 2))
      }

      const geometry = new THREE.Geometry();
      geometry.vertices = vertices;
      geometry.faces = faces;
      geometry.computeBoundingSphere();
      geometry.computeFaceNormals();
      geometry.computeVertexNormals();

      return geometry;
    }

    // Crate lane geometry
    function getLaneGeometry(points, width = 2, thick = 0.1) {
      let [leftLanePoints, rightLanePoints] = createThickLine(points, width)
      let leftLane = createThickLine(leftLanePoints, thick);
      let rightLane = createThickLine(rightLanePoints, thick);
      let leftLaneGeometry = getThickLineGeometry(leftLane);
      let rightLaneGeometry = getThickLineGeometry(rightLane);
      return [leftLaneGeometry, rightLaneGeometry];
    }

    // Get path function from segments
    function getPathFunction(segments) {
      // 'segments' is a list of tuples <radius, anlge(length)>.
      // If radius <= 0, then the given segment is regarded as a line with given length.
      // Else, the given segment is regarded as a arc with given radius and angle.

      let angle = 0;
      let pos1 = new Vec2D(0, 0);
      let pathFunctions = [];
      let segmentLengthes = [0];
      let totalLength = 0;

      segments.forEach(segment => {
        const a = angle; // Copy variable so that it would be immutable.
        const p = pos1.clone();
        if (segment[0] <= 0) {
          // Line segment
          pathFunctions.push(t => new Vec2D(Math.cos(a), Math.sin(a)).mul(segment[1] * t).add(p))
          totalLength += segment[1]
        } else {
          // Curve segment
          pathFunctions.push(t => new Vec2D(Math.cos(segment[1] * t) - 1, Math.sin(segment[1] * t)).rot(a - Math.sign(segment[1]) * Math.PI / 2).mul(segment[0]).add(p))
          totalLength += Math.abs(segment[0] * segment[1])
          angle += segment[1]
        }
        pos1 = pathFunctions[pathFunctions.length - 1](1);
        segmentLengthes.push(totalLength)
      });

      return x => {
        let t = x * totalLength
        let i;
        for (i = 0; i < pathFunctions.length; i++) {
          if (segmentLengthes[i] <= t && t <= segmentLengthes[i + 1]) {
            let sgementT = (t - segmentLengthes[i]) / (segmentLengthes[i + 1] - segmentLengthes[i]);
            return pathFunctions[i](sgementT)
          }
        }
        let sgementT = (t - segmentLengthes[i]) / (segmentLengthes[i + 1] - segmentLengthes[i]);
        return pathFunctions[i](sgementT)
      }
    }

    // Define a cube and add it to scene.
    let cube;
    {
      let geometry = new THREE.BoxGeometry();
      let material = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
      });
      cube = new THREE.Mesh(geometry, material);
      cube.position.set(0, -20, 0) // Hide cube
      cube.scale.set(20, 20, 20)
      scene.add(cube);
    }

    // Define ground
    let ground
    {
      const geometry = new THREE.PlaneGeometry(1000, 1000);
      const material = new THREE.MeshPhongMaterial({ color: 0x101010, side: THREE.DoubleSide });
      ground = new THREE.Mesh(geometry, material);
      ground.position.set(0, -0.1, 0)
      ground.lookAt(0, 1, 0)
      scene.add(ground);
    }

    // Define lane. Scale unit : Centimeter
    let lane;
    {
      lane = getPathFunction([
        [0, 150],
        [40, Math.PI * 5 / 4],
        [50, - Math.PI * 6 / 4],
        [35, Math.PI * 3 / 4],
        [0, 100],
        [40, -Math.PI],
        [0, 200]])
      let points = []
      for (let t = 0; t < 1; t += 0.01) {
        points.push(lane(t))
      }
      let [leftLaneGeometry, rightLaneGeometry] = getLaneGeometry(points, 40, 1.8);
      let material = new THREE.MeshPhongMaterial({ color: 0xffff40, side: THREE.DoubleSide })
      let leftLane = new THREE.Mesh(leftLaneGeometry, material);
      let rightLane = new THREE.Mesh(rightLaneGeometry, material);
      scene.add(leftLane);
      scene.add(rightLane);
    }

    // Define ambient light
    {
      let light = new THREE.AmbientLight(0x202020); // soft white light
      scene.add(light);
    }

    // Define spot lights
    {
      const dist = 200;
      const height = 100;
      for (let x = 0; x < 3; x++) {
        for (let y = 0; y < 3; y++) {
          let light = new THREE.PointLight(
            0xffffff, // Color
            1, // Intensity
            600, // Distance (0=No limit)
            1 // Some factor
          )
          light.position.set(x * dist, height, y * dist)
          scene.add(light)

          // White sphare to check light position
          let sphere = new THREE.Mesh(new THREE.SphereGeometry(), new THREE.MeshBasicMaterial())
          sphere.position.set(x * dist, height, y * dist);
          scene.add(sphere)
        }
      }
    }

    camera.position.set(-100, 170, -100)

    const pos = t => ((1 - Math.cos(t / 5000) * 0.98) / 2)
    const delta = 10
    function animate(t) {
      const pos1 = lane(pos(t));
      const pos2 = lane(pos(t + delta))
      const direction = pos2.sub(pos1);
      const theta = Math.atan2(direction.x, direction.y);

      if (0) {
        cube.position.set(pos1.x, 10, pos1.y);
        cube.rotation.y = theta + Math.PI;
        camera.lookAt(pos1.x, 0, pos1.y)
      } else {
        camera.position.set(pos1.x, 10, pos1.y);
        camera.lookAt(pos2.x, 10 - delta / 100, pos2.y)
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate(0);
  </script>
</body>

</html>