<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <script src="./three.js"></script>
  <script src="./vec2d.js"></script>
  <script src="./thick.js"></script>
  <style>
    body,
    html {
      margin: 0px;
      padding: 0px;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script>

    // Define scene, camera, renderer.
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(
      75, // Field of view
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near clipping plane
      1000 // Far clipping plane
    );
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(
      window.innerWidth,
      window.innerHeight,
      document.body.appendChild(renderer.domElement)
    );

    function getThickLineGeometry([left, right]) {
      let n = left.length
      let vertices = []
      let faces = []

      for (let i = 0; i < n; i++) {
        vertices.push(new THREE.Vector3(left[i].x, 0, left[i].y))
        vertices.push(new THREE.Vector3(right[i].x, 0, right[i].y))
      }

      for (let i = 0; i < n - 1; i++) {
        faces.push(new THREE.Face3(
          i * 2 + 2,
          i * 2 + 1,
          i * 2 + 0))
        faces.push(new THREE.Face3(
          i * 2 + 3,
          i * 2 + 1,
          i * 2 + 2))
      }

      const geometry = new THREE.Geometry();
      geometry.vertices = vertices;
      geometry.faces = faces;
      geometry.computeBoundingSphere();

      return geometry;
    }

    function getPath(segments) {
      // 'segments' is a list of tuples <radius, anlge(length)>.
      // If radius <= 0, then the given segment is regarded as a line with given length.
      // Else, the given segment is regarded as a arc with given radius and angle.

      let angle = 0;
      let pos = new Vec2D(0, 0);
      let pathFunctions = [];
      let segmentLengthes = [0];
      let totalLength = 0;

      segments.forEach(segment => {
        const a = angle; // Copy variable so that it would be immutable.
        const p = pos.clone();
        if (segment[0] <= 0) {
          // Line segment
          pathFunctions.push(t => new Vec2D(Math.cos(a), Math.sin(a)).mul(segment[1] * t).add(p))
          totalLength += segment[1]
        } else {
          // Curve segment
          pathFunctions.push(t => new Vec2D(Math.cos(segment[1] * t) - 1, Math.sin(segment[1] * t)).rot(a - Math.sign(segment[1]) * Math.PI / 2).mul(segment[0]).add(p))
          totalLength += Math.abs(segment[0] * segment[1])
          angle += segment[1]
        }
        pos = pathFunctions[pathFunctions.length - 1](1);
        segmentLengthes.push(totalLength)
      });

      return x => {
        let t = x * totalLength
        for (let i = 0; i < pathFunctions.length; i++) {
          if (segmentLengthes[i] <= t && t <= segmentLengthes[i + 1]) {
            let sgementT = (t - segmentLengthes[i]) / (segmentLengthes[i + 1] - segmentLengthes[i]);
            return pathFunctions[i](sgementT)
          }
        }
      }
    }

    // Crate lane geometry
    function getLaneGeometry(points, width = 2, thick = 0.1) {
      let [leftLanePoints, rightLanePoints] = createThickLine(points, width / 2)
      let leftLane = createThickLine(leftLanePoints, thick);
      let rightLane = createThickLine(rightLanePoints, thick);
      let leftLaneGeometry = getThickLineGeometry(leftLane);
      let rightLaneGeometry = getThickLineGeometry(rightLane);
      return [leftLaneGeometry, rightLaneGeometry];
    }

    // Define a cube and add it to scene.
    let cube;
    {
      let geometry = new THREE.BoxGeometry();
      let material = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
      });
      cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
    }


    // Define a plane
    // {
    //   const geometry = new THREE.PlaneGeometry(50, 50);
    //   const material = new THREE.MeshPhongMaterial({ color: 0x808080, side: THREE.DoubleSide });
    //   const plane = new THREE.Mesh(geometry, material);
    //   plane.position.set(0, 0, 0)
    //   plane.lookAt(0, 1, 0)
    //   scene.add(plane);
    // }

    // const lane = t => new Vec2D(t * Math.PI * 20, Math.sin(t * Math.PI * 2) * 10)
    const lane = getPath([
      [0, 5],
      [3, Math.PI / 2],
      [0, 5],
      [3, Math.PI / 2],
      [0, 10],
      [3, -Math.PI],
      [0, 5],]
    )

    // Define lane
    {
      let points = []
      let log = ""
      for (let i = 0; i < 1; i += 0.01) {
        let point = lane(i)
        points.push(point);
        log += point.x + "," + point.y + '\n'
      }
      console.log(log)
      let [leftLaneGeometry, rightLaneGeometry] = getLaneGeometry(points, 0.2, 0.01);
      let leftLane = new THREE.Mesh(leftLaneGeometry, new THREE.MeshBasicMaterial());
      let rightLane = new THREE.Mesh(rightLaneGeometry, new THREE.MeshBasicMaterial());
      scene.add(leftLane);
      scene.add(rightLane);
    }

    // Define lights
    {
      let light = new THREE.AmbientLight(0x404040); // soft white light
      scene.add(light);
    }
    {
      let light = new THREE.DirectionalLight(0xffffff, 0.5);
      scene.add(light);
    }

    camera.position.z = 10;

    function animate(t) {
      let t2 = ((Math.sin(t / 5000) + 1) / 2);
      let t3 = ((Math.sin((t + 2500) / 5000) + 1) / 2);
      let cam = lane(t2);
      let dst = lane(t3);

      camera.position.set(20, 10, 20);
      cube.position.set(dst.x, 0, dst.y);
      camera.lookAt(dst.x, 0, dst.y);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate(0);
  </script>
</body>

</html>